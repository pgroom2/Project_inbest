{"ast":null,"code":"import _get from \"C:\\\\Users\\\\peter\\\\repos\\\\Project_inbest\\\\angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\get.js\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\peter\\\\repos\\\\Project_inbest\\\\angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\getPrototypeOf.js\";\nimport _inherits from \"C:\\\\Users\\\\peter\\\\repos\\\\Project_inbest\\\\angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"C:\\\\Users\\\\peter\\\\repos\\\\Project_inbest\\\\angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport _classCallCheck from \"C:\\\\Users\\\\peter\\\\repos\\\\Project_inbest\\\\angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\peter\\\\repos\\\\Project_inbest\\\\angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport { EventEmitter, Output, Injectable, InjectionToken, Inject, Optional, NgZone, Component, ElementRef, ViewEncapsulation, Directive, ViewChild, ViewContainerRef, Input, NgModule } from '@angular/core';\nimport { Observable, ReplaySubject, Subject } from 'rxjs';\nimport { debounceTime, tap, first } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * return json string from json-like string\n * @param {?} str\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\nvar _c0 = [\"*\"];\nvar _c1 = [\"template\"];\n\nfunction jsonize(str) {\n  try {\n    // if parsable already, return as it is\n    JSON.parse(str);\n    return str;\n  } catch (\n  /** @type {?} */\n  e) {\n    // if not parsable, change little\n    return str.replace(/([\\$\\w]+)\\s*:/g, // wrap keys without double quote\n    // wrap keys without double quote\n    function (_, $1) {\n      return '\"' + $1 + '\":';\n    }).replace(/'([^']+)'/g, // replacing single quote to double quote\n    // replacing single quote to double quote\n    function (_, $1) {\n      return '\"' + $1 + '\"';\n    });\n  }\n}\n/**\n * Returns string to an object by using JSON.parse()\n * @param {?} input\n * @return {?}\n */\n\n\nfunction getJSON(input) {\n  if (typeof input === 'string') {\n    var\n    /** @type {?} */\n    re = /^[\\+\\-]?[0-9\\.]+,[ ]*\\ ?[\\+\\-]?[0-9\\.]+$/; // lat,lng\n\n    if (input.match(re)) {\n      input = '[' + input + ']';\n    }\n\n    return JSON.parse(jsonize(input));\n  } else {\n    return input;\n  }\n}\n/**\n * json type definition\n * @record\n */\n\n/**\n * Returns camel-cased from string 'Foo Bar' to 'fooBar'\n * @param {?} str\n * @return {?}\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (letter, index) {\n    return index === 0 ? letter.toLowerCase() : letter.toUpperCase();\n  }).replace(/\\s+/g, '');\n}\n/**\n * @return {?}\n */\n\n\nfunction isMapsApiLoaded() {\n  return typeof google === 'object' && typeof google.maps === 'object';\n}\n/**\n * @param {?} component\n * @param {?} libName\n * @return {?}\n */\n\n\nfunction missingLibraryError(component, libName) {\n  return Error(\"\".concat(component, \": library '\").concat(libName, \"' is missing, please ensure to include it in a 'libraries' parameter.\\n    Example:\\n      NguiMapModule.forRoot({\\n        apiUrl: 'https://maps.googleapis.com/maps/api/js?libraries=\").concat(libName, \"'\\n      })\\n  \"));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @abstract\n */\n\n\nvar BaseMapDirective = /*#__PURE__*/(function () {\n  var BaseMapDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} mapObjectName\n     * @param {?} inputs\n     * @param {?} outputs\n     */\n    function BaseMapDirective(nguiMapComponent, mapObjectName, inputs, outputs) {\n      var _this = this;\n\n      _classCallCheck(this, BaseMapDirective);\n\n      this.nguiMapComponent = nguiMapComponent;\n      this.mapObjectName = mapObjectName;\n      this.inputs = inputs;\n      this.outputs = outputs; // this should be redefined on each childr directive\n\n      this.initialized$ = new EventEmitter();\n      this._subscriptions = [];\n      this.nguiMap = this.nguiMapComponent['nguiMap'];\n      this.optionBuilder = this.nguiMapComponent['optionBuilder']; // all outputs must be initialized\n\n      this.outputs.forEach(function (output) {\n        return _this[output] = new EventEmitter();\n      });\n      this.mapObjectName = mapObjectName;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(BaseMapDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this2 = this;\n\n        if (this.nguiMapComponent.mapIdledOnce) {\n          // map is ready already\n          this.initialize();\n        } else {\n          this.nguiMapComponent.mapReady$.subscribe(function (map) {\n            return _this2.initialize();\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"initialize\",\n      value: function initialize() {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this); // will be set after geocoded\n\n        typeof this.objectOptions.position === 'string' && delete this.objectOptions.position;\n        typeof this.objectOptions.center === 'string' && delete this.objectOptions.center; // noinspection TypeScriptUnresolvedFunction\n\n        if (this.libraryName) {\n          if (!google.maps[this.libraryName]) {\n            throw missingLibraryError(this.mapObjectName, this.libraryName);\n          }\n\n          this.mapObject = new google.maps[this.libraryName][this.mapObjectName](this.objectOptions);\n        } else {\n          this.mapObject = new google.maps[this.mapObjectName](this.objectOptions);\n        }\n\n        this.mapObject.setMap(this.nguiMapComponent.map);\n        this.mapObject['mapObjectName'] = this.mapObjectName;\n        this.mapObject['nguiMapComponent'] = this.nguiMapComponent; // set google events listeners and emits to this outputs listeners\n\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.nguiMap.updateGoogleObject(this.mapObject, changes);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._subscriptions.map(function (subscription) {\n          return subscription.unsubscribe();\n        });\n\n        this.nguiMapComponent.removeFromMapObjectGroup(this.mapObjectName, this.mapObject);\n\n        if (this.mapObject) {\n          this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n        }\n      }\n    }]);\n\n    return BaseMapDirective;\n  }();\n\n  BaseMapDirective.ɵfac = function BaseMapDirective_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  BaseMapDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: BaseMapDirective,\n    outputs: {\n      initialized$: \"initialized$\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return BaseMapDirective;\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * change any object to google object options\n * e.g. [1,2] -> new google.maps.LatLng(1,2);\n */\nvar OptionBuilder = /*#__PURE__*/(function () {\n  var OptionBuilder = /*#__PURE__*/function () {\n    function OptionBuilder() {\n      _classCallCheck(this, OptionBuilder);\n    }\n\n    _createClass(OptionBuilder, [{\n      key: \"googlizeAllInputs\",\n      value:\n      /**\n       * @param {?} definedInputs\n       * @param {?} userInputs\n       * @return {?}\n       */\n      function googlizeAllInputs(definedInputs, userInputs) {\n        var _this3 = this;\n\n        var\n        /** @type {?} */\n        options = {}; // if options given from user, only take options and ignore other inputs\n\n        if (userInputs.options) {\n          options = userInputs.options;\n\n          if (!this.onlyOptionsGiven(definedInputs, userInputs)) {\n            console.error('when \"options\" are used, other options are ignored');\n          }\n        } else {\n          // if options not given, process all user inputs\n          definedInputs.forEach(function (input) {\n            if (userInputs[input] !== undefined) {\n              options[input] = _this3.googlize(userInputs[input], {\n                key: input\n              });\n            }\n          });\n        }\n\n        return options;\n      }\n      /**\n       * @param {?} inputs\n       * @param {?=} options\n       * @return {?}\n       */\n\n    }, {\n      key: \"googlizeMultiple\",\n      value: function googlizeMultiple(inputs, options) {\n        options = options || {};\n\n        for (var\n        /** @type {?} */\n        key in inputs) {\n          var\n          /** @type {?} */\n          val = inputs[key]; // (non-strings are fully converted)\n\n          if (typeof val !== 'string') {\n            options[key] = val;\n          } else if (!(options['doNotConverStringToNumber'] && val.match(/^[0-9]+$/))) {\n            options[key] = this.googlize(val, {\n              key: key\n            });\n          }\n        } // for(var key in attrs)\n\n\n        return options;\n      }\n      /**\n       * @param {?} input\n       * @param {?=} options\n       * @return {?}\n       */\n\n    }, {\n      key: \"googlize\",\n      value: function googlize(input, options) {\n        options = options || {};\n        var\n        /** @type {?} */\n        output = input;\n\n        if (typeof input === 'string') {\n          // convert string to a google object\n          if (input === 'false') {\n            output = false;\n          } else if (input === '0') {\n            output = 0;\n          } else {\n            output = // -> googlize -> getJsonParsed -> googlizeMultiple -> googlize until all elements are parsed\n            this.getJSONParsed(input, options)\n            /* Foo.Bar(...) -> new google.maps.Foo.Bar(...) */\n            || this.getAnyMapObject(input)\n            /*  MapTypeID.HYBRID -> new google.maps.MapTypeID.HYBRID */\n            || this.getAnyMapConstant(input, options)\n            /*  2016-06-20 -> new Date('2016-06-20') */\n            || this.getDateObject(input) || input;\n          }\n        }\n\n        if (options['key']) {\n          var\n          /** @type {?} */\n          key =\n          /** @type {?} */\n          options['key'];\n\n          if (output instanceof Array) {\n            // e.g., [1, 2]\n            if (key === 'bounds') {\n              output = new google.maps.LatLngBounds(output[0], output[1]);\n            } else if (key === 'icons') {\n              output = this.getMapIcons(output);\n            } else if (key === 'position' || key.match(/^geoFallback/)) {\n              output = this.getLatLng(output);\n            }\n          } else if (output instanceof Object) {\n            if (key === 'icon') {\n              output = this.getMarkerIcon(output);\n            } else if (key.match(/ControlOptions$/)) {\n              output = this.getMapControlOption(output);\n            }\n          }\n        } // delete keys only for processing, not used by google\n\n\n        delete output['doNotConverStringToNumber'];\n        delete output['key'];\n        return output;\n      }\n      /**\n       * @param {?} input\n       * @return {?}\n       */\n\n    }, {\n      key: \"getLatLng\",\n      value: function getLatLng(input) {\n        var\n        /** @type {?} */\n        output;\n\n        if (input[0].constructor === Array) {\n          // [[1,2],[3,4]]\n          output =\n          /** @type {?} */\n          input.map(function (el) {\n            return new google.maps.LatLng(el[0], el[1]);\n          });\n        } else if (!isNaN(parseFloat(input[0])) && isFinite(input[0])) {\n          output = new google.maps.LatLng(input[0], input[1]);\n        }\n\n        return output;\n      }\n      /**\n       * @param {?} input\n       * @param {?} options\n       * @return {?}\n       */\n\n    }, {\n      key: \"getJSONParsed\",\n      value: function getJSONParsed(input, options) {\n        var\n        /** @type {?} */\n        output;\n\n        try {\n          output = getJSON(input);\n\n          if (output instanceof Array) {\n            // [{a:1}] : not lat/lng ones\n            if (output[0].constructor !== Object) {\n              // [[1,2],[3,4]] or [1,2]\n              output = this.getLatLng(output);\n            }\n          } else if (output === Object(output)) {\n            // check for nested hashes and convert to Google API options\n            var\n            /** @type {?} */\n            newOptions = options;\n            newOptions['doNotConverStringToNumber'] = true;\n            output = this.googlizeMultiple(output, newOptions);\n          }\n        } catch (\n        /** @type {?} */\n        e) {}\n\n        return output;\n      }\n      /**\n       * @param {?} input\n       * @return {?}\n       */\n\n    }, {\n      key: \"getAnyMapObject\",\n      value: function getAnyMapObject(input) {\n        var\n        /** @type {?} */\n        output;\n\n        if (input.match(/^[A-Z][a-zA-Z0-9]+\\(.*\\)$/)) {\n          try {\n            output = Function(\"return new google.maps.\".concat(input, \";\"))();\n          } catch (\n          /** @type {?} */\n          e) {}\n        }\n\n        return output;\n      }\n      /**\n       * @param {?} input\n       * @param {?} options\n       * @return {?}\n       */\n\n    }, {\n      key: \"getAnyMapConstant\",\n      value: function getAnyMapConstant(input, options) {\n        var\n        /** @type {?} */\n        output;\n\n        if (input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/)) {\n          // e.g. MapTypeID.HYBRID\n          try {\n            var\n            /** @type {?} */\n            matches = input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/);\n            output = google.maps[matches[1]][matches[2]];\n          } catch (\n          /** @type {?} */\n          e) {}\n        } else if (input.match(/^[A-Z]+$/)) {\n          // e.g. HYBRID\n          try {\n            var\n            /** @type {?} */\n            capitalizedKey =\n            /** @type {?} */\n            options['key'].charAt(0).toUpperCase() +\n            /** @type {?} */\n            options['key'].slice(1);\n            output = google.maps[capitalizedKey][input];\n          } catch (\n          /** @type {?} */\n          e) {}\n        }\n\n        return output;\n      }\n      /**\n       * streetviewControl, panControl, etc, not a general control\n       * @param {?} controlOptions\n       * @return {?}\n       */\n\n    }, {\n      key: \"getMapControlOption\",\n      value: function getMapControlOption(controlOptions) {\n        var\n        /** @type {?} */\n        newControlOptions = controlOptions;\n\n        for (var\n        /** @type {?} */\n        key in newControlOptions) {\n          // assign the right values\n          if (newControlOptions[key]) {\n            var\n            /** @type {?} */\n            value = newControlOptions[key];\n\n            if (typeof value === 'string') {\n              value =\n              /** @type {?} */\n              value.toUpperCase();\n            } else if (key === 'mapTypeIds') {\n              value =\n              /** @type {?} */\n              value.map(function (str) {\n                if (str.match(/^[A-Z]+$/)) {\n                  // if constant\n                  return google.maps.MapTypeId[str.toUpperCase()];\n                } else {\n                  // else, custom map-type\n                  return str;\n                }\n              });\n            }\n\n            if (key === 'style') {\n              var\n              /** @type {?} */\n              objName = key.replace(/Options$/, '') + 'Style';\n              newControlOptions[key] = google.maps[objName][\n              /** @type {?} */\n              value];\n            } else if (key === 'position') {\n              newControlOptions[key] = google.maps.ControlPosition[\n              /** @type {?} */\n              value];\n            } else {\n              newControlOptions[key] = value;\n            }\n          }\n        }\n\n        return newControlOptions;\n      }\n      /**\n       * @param {?} input\n       * @return {?}\n       */\n\n    }, {\n      key: \"getDateObject\",\n      value: function getDateObject(input) {\n        var\n        /** @type {?} */\n        output;\n\n        if (input.match(/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/)) {\n          try {\n            output = new Date(input);\n          } catch (\n          /** @type {?} */\n          e) {}\n        }\n\n        return output;\n      }\n      /**\n       * @param {?} input\n       * @return {?}\n       */\n\n    }, {\n      key: \"getMapIcons\",\n      value: function getMapIcons(input) {\n        return input.map(function (el) {\n          if (el.icon.path.match(/^[A-Z_]+$/)) {\n            el.icon.path = google.maps.SymbolPath[el.icon.path];\n          }\n\n          return el;\n        });\n      }\n      /**\n       * @param {?} input\n       * @return {?}\n       */\n\n    }, {\n      key: \"getMarkerIcon\",\n      value: function getMarkerIcon(input) {\n        var\n        /** @type {?} */\n        output = input;\n\n        if (('' + output.path).match(/^[A-Z_]+$/)) {\n          output.path = google.maps.SymbolPath[output.path];\n        }\n\n        for (var\n        /** @type {?} */\n        key in output) {\n          var\n          /** @type {?} */\n          arr = output[key];\n\n          if (key === 'anchor' || key === 'origin' || key === 'labelOrigin') {\n            output[key] = new google.maps.Point(arr[0], arr[1]);\n          } else if (key === 'size' || key === 'scaledSize') {\n            output[key] = new google.maps.Size(arr[0], arr[1]);\n          }\n        }\n\n        return output;\n      }\n      /**\n       * @param {?} definedInputs\n       * @param {?} userInputs\n       * @return {?}\n       */\n\n    }, {\n      key: \"onlyOptionsGiven\",\n      value: function onlyOptionsGiven(definedInputs, userInputs) {\n        for (var\n        /** @type {?} */\n        i = 0; i < definedInputs.length; i++) {\n          var\n          /** @type {?} */\n          input = definedInputs[i];\n\n          if (input !== 'options' && typeof userInputs[input] !== 'undefined') {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }]);\n\n    return OptionBuilder;\n  }();\n\n  OptionBuilder.ɵfac = function OptionBuilder_Factory(t) {\n    return new (t || OptionBuilder)();\n  };\n\n  OptionBuilder.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: OptionBuilder,\n    factory: OptionBuilder.ɵfac\n  });\n  return OptionBuilder;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n *  service for navigator.geolocation methods\n */\n\n\nvar NavigatorGeolocation = /*#__PURE__*/(function () {\n  var NavigatorGeolocation = /*#__PURE__*/function () {\n    function NavigatorGeolocation() {\n      _classCallCheck(this, NavigatorGeolocation);\n    }\n\n    _createClass(NavigatorGeolocation, [{\n      key: \"getCurrentPosition\",\n      value:\n      /**\n       * @param {?=} geoLocationOptions\n       * @return {?}\n       */\n      function getCurrentPosition(geoLocationOptions) {\n        geoLocationOptions = geoLocationOptions || {\n          timeout: 5000\n        };\n        return new Observable(function (responseObserver) {\n          if (navigator.geolocation) {\n            navigator.geolocation.getCurrentPosition(function (position) {\n              responseObserver.next(position);\n              responseObserver.complete();\n            }, function (evt) {\n              return responseObserver.error(evt);\n            }, geoLocationOptions);\n          } else {\n            responseObserver.error('Browser Geolocation service failed.');\n          }\n        });\n      }\n    }]);\n\n    return NavigatorGeolocation;\n  }();\n\n  NavigatorGeolocation.ɵfac = function NavigatorGeolocation_Factory(t) {\n    return new (t || NavigatorGeolocation)();\n  };\n\n  NavigatorGeolocation.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NavigatorGeolocation,\n    factory: NavigatorGeolocation.ɵfac\n  });\n  return NavigatorGeolocation;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar NG_MAP_CONFIG_TOKEN = new InjectionToken('NG_MAP_CONFIG_TOKEN');\n/**\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @abstract\n */\n\nvar NgMapApiLoader = /*#__PURE__*/(function () {\n  var NgMapApiLoader = /*#__PURE__*/function () {\n    /**\n     * @param {?} config\n     */\n    function NgMapApiLoader(config) {\n      _classCallCheck(this, NgMapApiLoader);\n\n      this.config = config;\n      this.api$ = new ReplaySubject(1);\n      this.config = this.config || {\n        apiUrl: 'https://maps.google.com/maps/api/js'\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(NgMapApiLoader, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.api$.complete();\n      }\n    }]);\n\n    return NgMapApiLoader;\n  }();\n\n  NgMapApiLoader.ɵfac = function NgMapApiLoader_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  NgMapApiLoader.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NgMapApiLoader\n  });\n  return NgMapApiLoader;\n})();\nvar NgMapAsyncCallbackApiLoader = /*#__PURE__*/(function () {\n  var NgMapAsyncCallbackApiLoader = /*#__PURE__*/function (_NgMapApiLoader) {\n    _inherits(NgMapAsyncCallbackApiLoader, _NgMapApiLoader);\n\n    var _super = _createSuper(NgMapAsyncCallbackApiLoader);\n\n    /**\n     * @param {?} zone\n     * @param {?} config\n     */\n    function NgMapAsyncCallbackApiLoader(zone, config) {\n      var _this4;\n\n      _classCallCheck(this, NgMapAsyncCallbackApiLoader);\n\n      _this4 = _super.call(this, config);\n      _this4.zone = zone;\n      return _this4;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(NgMapAsyncCallbackApiLoader, [{\n      key: \"load\",\n      value: function load() {\n        var _this5 = this;\n\n        if (typeof window === 'undefined') {\n          return;\n        }\n\n        if (isMapsApiLoaded()) {\n          this.api$.next(google.maps);\n        } else if (!document.querySelector('#ngui-map-api')) {\n          /** @type {?} */\n          window['nguiMapRef'] =\n          /** @type {?} */\n          window['nguiMapRef'] || [];\n\n          /** @type {?} */\n          window['nguiMapRef'].push({\n            zone: this.zone,\n            componentFn: function componentFn() {\n              return _this5.api$.next(google.maps);\n            }\n          });\n          this.addGoogleMapsApi();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"addGoogleMapsApi\",\n      value: function addGoogleMapsApi() {\n        /** @type {?} */\n        window['initNguiMap'] =\n        /** @type {?} */\n        window['initNguiMap'] || function () {\n          /** @type {?} */\n          window['nguiMapRef'].forEach(function (nguiMapRef) {\n            nguiMapRef.zone.run(function () {\n              nguiMapRef.componentFn();\n            });\n          });\n\n          /** @type {?} */\n          window['nguiMapRef'].splice(0,\n          /** @type {?} */\n          window['nguiMapRef'].length);\n        };\n\n        var\n        /** @type {?} */\n        script = document.createElement('script');\n        script.id = 'ngui-map-api'; // script.src = \"https://maps.google.com/maps/api/js?callback=initNguiMap\";\n\n        var\n        /** @type {?} */\n        apiUrl = this.config.apiUrl;\n        apiUrl += apiUrl.indexOf('?') !== -1 ? '&' : '?';\n        script.src = apiUrl + 'callback=initNguiMap';\n        document.querySelector('body').appendChild(script);\n      }\n    }]);\n\n    return NgMapAsyncCallbackApiLoader;\n  }(NgMapApiLoader);\n\n  NgMapAsyncCallbackApiLoader.ɵfac = function NgMapAsyncCallbackApiLoader_Factory(t) {\n    return new (t || NgMapAsyncCallbackApiLoader)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NG_MAP_CONFIG_TOKEN, 8));\n  };\n\n  NgMapAsyncCallbackApiLoader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgMapAsyncCallbackApiLoader,\n    factory: NgMapAsyncCallbackApiLoader.ɵfac\n  });\n  /** @nocollapse */\n\n  return NgMapAsyncCallbackApiLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar NgMapAsyncApiLoader = /*#__PURE__*/(function () {\n  var NgMapAsyncApiLoader = /*#__PURE__*/function (_NgMapApiLoader2) {\n    _inherits(NgMapAsyncApiLoader, _NgMapApiLoader2);\n\n    var _super2 = _createSuper(NgMapAsyncApiLoader);\n\n    /**\n     * @param {?} config\n     */\n    function NgMapAsyncApiLoader(config) {\n      _classCallCheck(this, NgMapAsyncApiLoader);\n\n      return _super2.call(this, config);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(NgMapAsyncApiLoader, [{\n      key: \"load\",\n      value: function load() {\n        var _this6 = this;\n\n        if (typeof window === 'undefined') {\n          return;\n        }\n\n        if (isMapsApiLoaded()) {\n          this.api$.next(google.maps);\n        } else if (!document.querySelector('#ngui-map-api')) {\n          var\n          /** @type {?} */\n          script = document.createElement('script');\n          script.id = 'ngui-map-api';\n          script.async = true;\n\n          script.onload = function () {\n            return _this6.api$.next(google.maps);\n          };\n\n          script.src = this.config.apiUrl;\n          document.querySelector('body').appendChild(script);\n        }\n      }\n    }]);\n\n    return NgMapAsyncApiLoader;\n  }(NgMapApiLoader);\n\n  NgMapAsyncApiLoader.ɵfac = function NgMapAsyncApiLoader_Factory(t) {\n    return new (t || NgMapAsyncApiLoader)(ɵngcc0.ɵɵinject(NG_MAP_CONFIG_TOKEN, 8));\n  };\n\n  NgMapAsyncApiLoader.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgMapAsyncApiLoader,\n    factory: NgMapAsyncApiLoader.ɵfac\n  });\n  /** @nocollapse */\n\n  return NgMapAsyncApiLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n *   Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n *   service for Google Geocoder service\n */\n\n\nvar GeoCoder = /*#__PURE__*/(function () {\n  var GeoCoder = /*#__PURE__*/function () {\n    /**\n     * @param {?} apiLoader\n     */\n    function GeoCoder(apiLoader) {\n      _classCallCheck(this, GeoCoder);\n\n      this.apiLoader = apiLoader;\n      this.apiLoaderSubs = [];\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    _createClass(GeoCoder, [{\n      key: \"geocode\",\n      value: function geocode(options) {\n        var _this7 = this;\n\n        return new Observable(function (responseObserver) {\n          _this7.apiLoaderSubs.push(_this7.apiLoader.api$.subscribe(function () {\n            return _this7.requestGeocode(options, responseObserver);\n          }));\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.apiLoaderSubs.map(function (sub) {\n          return sub.unsubscribe();\n        });\n      }\n      /**\n       * @param {?} options\n       * @param {?} observer\n       * @return {?}\n       */\n\n    }, {\n      key: \"requestGeocode\",\n      value: function requestGeocode(options, observer) {\n        var\n        /** @type {?} */\n        geocoder = new google.maps.Geocoder();\n        geocoder.geocode(options, function (results, status) {\n          if (status === google.maps.GeocoderStatus.OK) {\n            observer.next(results);\n            observer.complete();\n          } else {\n            observer.error(results);\n          }\n        });\n      }\n    }]);\n\n    return GeoCoder;\n  }();\n\n  GeoCoder.ɵfac = function GeoCoder_Factory(t) {\n    return new (t || GeoCoder)(ɵngcc0.ɵɵinject(NgMapApiLoader));\n  };\n\n  GeoCoder.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: GeoCoder,\n    factory: GeoCoder.ɵfac\n  });\n  /** @nocollapse */\n\n  return GeoCoder;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * collection of map instance-related properties and methods\n */\n\n\nvar NguiMap = /*#__PURE__*/(function () {\n  var NguiMap = /*#__PURE__*/function () {\n    /**\n     * @param {?} geoCoder\n     * @param {?} optionBuilder\n     * @param {?} zone\n     */\n    function NguiMap(geoCoder, optionBuilder, zone) {\n      var _this8 = this;\n\n      _classCallCheck(this, NguiMap);\n\n      this.geoCoder = geoCoder;\n      this.optionBuilder = optionBuilder;\n      this.zone = zone;\n\n      this.updateGoogleObject = function (object, changes) {\n        var\n        /** @type {?} */\n        val,\n        /** @type {?} */\n        currentValue,\n        /** @type {?} */\n        setMethodName;\n\n        if (object) {\n          for (var\n          /** @type {?} */\n          key in changes) {\n            setMethodName = \"set\".concat(key.replace(/^[a-z]/, function (x) {\n              return x.toUpperCase();\n            }));\n            currentValue = changes[key].currentValue;\n\n            if (['position', 'center'].indexOf(key) !== -1 && typeof currentValue === 'string') {\n              // To preserve setMethod name in Observable callback, wrap it as a function, then execute\n              (function (setMethodName) {\n                _this8.geoCoder.geocode({\n                  address: currentValue\n                }).subscribe(function (results) {\n                  if (typeof object[setMethodName] === 'function') {\n                    object[setMethodName](results[0].geometry.location);\n                  } else {\n                    console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' + 'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n                  }\n                });\n              })(setMethodName);\n            } else {\n              val = _this8.optionBuilder.googlize(currentValue);\n\n              if (typeof object[setMethodName] === 'function') {\n                object[setMethodName](val);\n              } else {\n                console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' + 'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n              }\n            }\n          }\n        }\n      };\n    }\n    /**\n     * @param {?} definedEvents\n     * @param {?} thisObj\n     * @param {?} prefix\n     * @return {?}\n     */\n\n\n    _createClass(NguiMap, [{\n      key: \"setObjectEvents\",\n      value: function setObjectEvents(definedEvents, thisObj, prefix) {\n        var _this9 = this;\n\n        definedEvents.forEach(function (definedEvent) {\n          var\n          /** @type {?} */\n          eventName = _this9.getEventName(definedEvent),\n\n          /** @type {?} */\n          zone = _this9.zone;\n\n          zone.runOutsideAngular(function () {\n            thisObj[prefix].addListener(eventName, function (event) {\n              var\n              /** @type {?} */\n              param = event ? event : {};\n              param.target = this;\n              zone.run(function () {\n                return thisObj[definedEvent].emit(param);\n              });\n            });\n          });\n        });\n      }\n      /**\n       * @param {?} definedEvents\n       * @param {?} thisObj\n       * @param {?} prefix\n       * @return {?}\n       */\n\n    }, {\n      key: \"clearObjectEvents\",\n      value: function clearObjectEvents(definedEvents, thisObj, prefix) {\n        var _this10 = this;\n\n        definedEvents.forEach(function (definedEvent) {\n          var\n          /** @type {?} */\n          eventName = _this10.getEventName(definedEvent);\n\n          _this10.zone.runOutsideAngular(function () {\n            if (thisObj[prefix]) {\n              google.maps.event.clearListeners(thisObj[prefix], eventName);\n            }\n          });\n        });\n\n        if (thisObj[prefix]) {\n          if (thisObj[prefix].setMap) {\n            thisObj[prefix].setMap(null);\n          }\n\n          delete thisObj[prefix].nguiMapComponent;\n          delete thisObj[prefix];\n        }\n      }\n      /**\n       * @param {?} definedEvent\n       * @return {?}\n       */\n\n    }, {\n      key: \"getEventName\",\n      value: function getEventName(definedEvent) {\n        return definedEvent.replace(/([A-Z])/g, function ($1) {\n          return \"_\".concat($1.toLowerCase());\n        }) // positionChanged -> position_changed\n        .replace(/^map_/, ''); // map_click -> click  to avoid DOM conflicts\n      }\n    }]);\n\n    return NguiMap;\n  }();\n\n  NguiMap.ɵfac = function NguiMap_Factory(t) {\n    return new (t || NguiMap)(ɵngcc0.ɵɵinject(GeoCoder), ɵngcc0.ɵɵinject(OptionBuilder), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  NguiMap.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NguiMap,\n    factory: NguiMap.ɵfac\n  });\n  /** @nocollapse */\n\n  return NguiMap;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS = ['backgroundColor', 'center', 'disableDefaultUI', 'disableDoubleClickZoom', 'draggable', 'draggableCursor', 'draggingCursor', 'heading', 'keyboardShortcuts', 'mapMaker', 'mapTypeControl', 'mapTypeId', 'maxZoom', 'minZoom', 'noClear', 'overviewMapControl', 'panControl', 'panControlOptions', 'rotateControl', 'scaleControl', 'scrollwheel', 'streetView', 'styles', 'tilt', 'zoom', 'streetViewControl', 'zoomControl', 'zoomControlOptions', 'mapTypeControlOptions', 'overviewMapControlOptions', 'rotateControlOptions', 'scaleControlOptions', 'streetViewControlOptions', 'fullscreenControl', 'fullscreenControlOptions', 'options', 'geoFallbackCenter'];\nvar OUTPUTS = ['bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'heading_changed', 'idle', 'maptypeid_changed', 'mousemove', 'mouseout', 'mouseover', 'projection_changed', 'resize', 'rightclick', 'tilesloaded', 'tile_changed', 'zoom_changed', 'mapClick', 'mapMouseover', 'mapMouseout', 'mapMousemove', 'mapDrag', 'mapDragend', 'mapDragstart'];\nvar NguiMapComponent = /*#__PURE__*/(function () {\n  var NguiMapComponent = /*#__PURE__*/function () {\n    /**\n     * @param {?} optionBuilder\n     * @param {?} elementRef\n     * @param {?} geolocation\n     * @param {?} geoCoder\n     * @param {?} nguiMap\n     * @param {?} apiLoader\n     * @param {?} zone\n     */\n    function NguiMapComponent(optionBuilder, elementRef, geolocation, geoCoder, nguiMap, apiLoader, zone) {\n      var _this11 = this;\n\n      _classCallCheck(this, NguiMapComponent);\n\n      this.optionBuilder = optionBuilder;\n      this.elementRef = elementRef;\n      this.geolocation = geolocation;\n      this.geoCoder = geoCoder;\n      this.nguiMap = nguiMap;\n      this.apiLoader = apiLoader;\n      this.zone = zone;\n      this.mapReady$ = new EventEmitter();\n      this.mapOptions = {};\n      this.inputChanges$ = new Subject();\n      this.infoWindows = {};\n      this.mapIdledOnce = false;\n      this.initializeMapAfterDisplayed = false;\n      apiLoader.load(); // all outputs needs to be initialized,\n      // http://stackoverflow.com/questions/37765519/angular2-directive-cannot-read-property-subscribe-of-undefined-with-outputs\n\n      OUTPUTS.forEach(function (output) {\n        return _this11[output] = new EventEmitter();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(NguiMapComponent, [{\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this12 = this;\n\n        this.apiLoaderSub = this.apiLoader.api$.pipe(first()).subscribe(function () {\n          return _this12.initializeMap();\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewChecked\",\n      value: function ngAfterViewChecked() {\n        if (this.initializeMapAfterDisplayed && this.el && this.el.offsetWidth > 0) {\n          this.initializeMap();\n        }\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.inputChanges$.next(changes);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"initializeMap\",\n      value: function initializeMap() {\n        var _this13 = this;\n\n        this.el = this.elementRef.nativeElement.querySelector('.google-map');\n\n        if (this.el && this.el.offsetWidth === 0) {\n          this.initializeMapAfterDisplayed = true;\n          return;\n        }\n\n        this.initializeMapAfterDisplayed = false;\n        this.mapOptions = this.optionBuilder.googlizeAllInputs(INPUTS, this);\n        this.mapOptions.zoom = this.mapOptions.zoom || 15;\n        typeof this.mapOptions.center === 'string' && delete this.mapOptions.center;\n        this.zone.runOutsideAngular(function () {\n          _this13.map = new google.maps.Map(_this13.el, _this13.mapOptions);\n          _this13.map['mapObjectName'] = 'NguiMapComponent';\n\n          if (!_this13.mapOptions.center) {\n            // if center is not given as lat/lng\n            _this13.setCenter();\n          } // set google events listeners and emits to this outputs listeners\n\n\n          _this13.nguiMap.setObjectEvents(OUTPUTS, _this13, 'map');\n\n          _this13.map.addListener('idle', function () {\n            if (!_this13.mapIdledOnce) {\n              _this13.mapIdledOnce = true;\n              setTimeout(function () {\n                // Why????, subsribe and emit must not be in the same cycle???\n                _this13.mapReady$.emit(_this13.map);\n              });\n            }\n          }); // update map when input changes\n\n\n          _this13.inputChanges$.pipe(debounceTime(1000), tap(function (changes) {\n            return _this13.nguiMap.updateGoogleObject(_this13.map, changes);\n          })).subscribe();\n\n          if (typeof window !== 'undefined' &&\n          /** @type {?} */\n          window['nguiMapRef']) {\n            // expose map object for test and debugging on (<any>window)\n\n            /** @type {?} */\n            window['nguiMapRef'].map = _this13.map;\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"setCenter\",\n      value: function setCenter() {\n        var _this14 = this;\n\n        if (!this['center']) {\n          // center is not from user. Thus, we set the current location\n          this.geolocation.getCurrentPosition().subscribe(function (position) {\n            var\n            /** @type {?} */\n            latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n\n            _this14.map.setCenter(latLng);\n          }, function (error) {\n            console.error('ngui-map: Error finding the current position');\n\n            _this14.map.setCenter(_this14.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n          });\n        } else if (typeof this['center'] === 'string') {\n          this.geoCoder.geocode({\n            address: this['center']\n          }).subscribe(function (results) {\n            _this14.map.setCenter(results[0].geometry.location);\n          }, function (error) {\n            _this14.map.setCenter(_this14.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n          });\n        }\n      }\n      /**\n       * @param {?} id\n       * @param {?} anchor\n       * @return {?}\n       */\n\n    }, {\n      key: \"openInfoWindow\",\n      value: function openInfoWindow(id, anchor) {\n        this.infoWindows[id].open(anchor);\n      }\n      /**\n       * @param {?} id\n       * @return {?}\n       */\n\n    }, {\n      key: \"closeInfoWindow\",\n      value: function closeInfoWindow(id) {\n        // if infoWindow for id exists, close the infoWindow\n        if (this.infoWindows[id]) this.infoWindows[id].close();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.inputChanges$.complete();\n\n        if (this.el && !this.initializeMapAfterDisplayed) {\n          this.nguiMap.clearObjectEvents(OUTPUTS, this, 'map');\n        }\n\n        if (this.apiLoaderSub) {\n          this.apiLoaderSub.unsubscribe();\n        }\n      }\n      /**\n       * @param {?} mapObjectName\n       * @param {?} mapObject\n       * @return {?}\n       */\n\n    }, {\n      key: \"addToMapObjectGroup\",\n      value: function addToMapObjectGroup(mapObjectName, mapObject) {\n        var\n        /** @type {?} */\n        groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n\n        this.map[groupName] = this.map[groupName] || [];\n        this.map[groupName].push(mapObject);\n      }\n      /**\n       * @param {?} mapObjectName\n       * @param {?} mapObject\n       * @return {?}\n       */\n\n    }, {\n      key: \"removeFromMapObjectGroup\",\n      value: function removeFromMapObjectGroup(mapObjectName, mapObject) {\n        var\n        /** @type {?} */\n        groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n\n        if (this.map && this.map[groupName]) {\n          var\n          /** @type {?} */\n          index = this.map[groupName].indexOf(mapObject);\n          index > -1 && this.map[groupName].splice(index, 1);\n        }\n      }\n    }]);\n\n    return NguiMapComponent;\n  }();\n\n  NguiMapComponent.ɵfac = function NguiMapComponent_Factory(t) {\n    return new (t || NguiMapComponent)(ɵngcc0.ɵɵdirectiveInject(OptionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigatorGeolocation), ɵngcc0.ɵɵdirectiveInject(GeoCoder), ɵngcc0.ɵɵdirectiveInject(NguiMap), ɵngcc0.ɵɵdirectiveInject(NgMapApiLoader), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  NguiMapComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NguiMapComponent,\n    selectors: [[\"ngui-map\"]],\n    inputs: {\n      backgroundColor: \"backgroundColor\",\n      center: \"center\",\n      disableDefaultUI: \"disableDefaultUI\",\n      disableDoubleClickZoom: \"disableDoubleClickZoom\",\n      draggable: \"draggable\",\n      draggableCursor: \"draggableCursor\",\n      draggingCursor: \"draggingCursor\",\n      heading: \"heading\",\n      keyboardShortcuts: \"keyboardShortcuts\",\n      mapMaker: \"mapMaker\",\n      mapTypeControl: \"mapTypeControl\",\n      mapTypeId: \"mapTypeId\",\n      maxZoom: \"maxZoom\",\n      minZoom: \"minZoom\",\n      noClear: \"noClear\",\n      overviewMapControl: \"overviewMapControl\",\n      panControl: \"panControl\",\n      panControlOptions: \"panControlOptions\",\n      rotateControl: \"rotateControl\",\n      scaleControl: \"scaleControl\",\n      scrollwheel: \"scrollwheel\",\n      streetView: \"streetView\",\n      styles: \"styles\",\n      tilt: \"tilt\",\n      zoom: \"zoom\",\n      streetViewControl: \"streetViewControl\",\n      zoomControl: \"zoomControl\",\n      zoomControlOptions: \"zoomControlOptions\",\n      mapTypeControlOptions: \"mapTypeControlOptions\",\n      overviewMapControlOptions: \"overviewMapControlOptions\",\n      rotateControlOptions: \"rotateControlOptions\",\n      scaleControlOptions: \"scaleControlOptions\",\n      streetViewControlOptions: \"streetViewControlOptions\",\n      fullscreenControl: \"fullscreenControl\",\n      fullscreenControlOptions: \"fullscreenControlOptions\",\n      options: \"options\",\n      geoFallbackCenter: \"geoFallbackCenter\"\n    },\n    outputs: {\n      bounds_changed: \"bounds_changed\",\n      center_changed: \"center_changed\",\n      click: \"click\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      dragstart: \"dragstart\",\n      heading_changed: \"heading_changed\",\n      idle: \"idle\",\n      maptypeid_changed: \"maptypeid_changed\",\n      mousemove: \"mousemove\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      projection_changed: \"projection_changed\",\n      resize: \"resize\",\n      rightclick: \"rightclick\",\n      tilesloaded: \"tilesloaded\",\n      tile_changed: \"tile_changed\",\n      zoom_changed: \"zoom_changed\",\n      mapClick: \"mapClick\",\n      mapMouseover: \"mapMouseover\",\n      mapMouseout: \"mapMouseout\",\n      mapMousemove: \"mapMousemove\",\n      mapDrag: \"mapDrag\",\n      mapDragend: \"mapDragend\",\n      mapDragstart: \"mapDragstart\",\n      mapReady$: \"mapReady$\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([NguiMap, OptionBuilder, GeoCoder, NavigatorGeolocation]), ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"google-map\"]],\n    template: function NguiMapComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n      }\n    },\n    styles: [\"\\n    ngui-map {display: block; height: 300px;}\\n    .google-map {width: 100%; height: 100%}\\n  \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return NguiMapComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$1 = [];\nvar OUTPUTS$1 = [];\nvar BicyclingLayer = /*#__PURE__*/(function () {\n  var BicyclingLayer = /*#__PURE__*/function (_BaseMapDirective) {\n    _inherits(BicyclingLayer, _BaseMapDirective);\n\n    var _super3 = _createSuper(BicyclingLayer);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function BicyclingLayer(nguiMapComp) {\n      _classCallCheck(this, BicyclingLayer);\n\n      return _super3.call(this, nguiMapComp, 'BicyclingLayer', INPUTS$1, OUTPUTS$1);\n    }\n\n    return _createClass(BicyclingLayer);\n  }(BaseMapDirective);\n\n  BicyclingLayer.ɵfac = function BicyclingLayer_Factory(t) {\n    return new (t || BicyclingLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  BicyclingLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: BicyclingLayer,\n    selectors: [[\"bicycling-layer\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return BicyclingLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$2 = ['content', 'disableAutoPan', 'maxWidth', 'pixelOffset', 'position', 'zIndex', 'options'];\nvar OUTPUTS$2 = ['closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'];\nvar InfoWindow = /*#__PURE__*/(function () {\n  var InfoWindow = /*#__PURE__*/function () {\n    /**\n     * @param {?} elementRef\n     * @param {?} nguiMap\n     * @param {?} nguiMapComponent\n     */\n    function InfoWindow(elementRef, nguiMap, nguiMapComponent) {\n      var _this15 = this;\n\n      _classCallCheck(this, InfoWindow);\n\n      this.elementRef = elementRef;\n      this.nguiMap = nguiMap;\n      this.nguiMapComponent = nguiMapComponent;\n      this.initialized$ = new EventEmitter();\n      this.objectOptions = {};\n      this.inputChanges$ = new Subject();\n      this.elementRef.nativeElement.style.display = 'none';\n      OUTPUTS$2.forEach(function (output) {\n        return _this15[output] = new EventEmitter();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(InfoWindow, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this16 = this;\n\n        if (this.nguiMapComponent.mapIdledOnce) {\n          // map is ready already\n          this.initialize();\n        } else {\n          this.nguiMapComponent.mapReady$.subscribe(function (map) {\n            return _this16.initialize();\n          });\n        }\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.inputChanges$.next(changes);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"initialize\",\n      value: function initialize() {\n        var _this17 = this;\n\n        this.objectOptions = this.nguiMapComponent.optionBuilder.googlizeAllInputs(INPUTS$2, this);\n        this.infoWindow = new google.maps.InfoWindow(this.objectOptions);\n        this.infoWindow['mapObjectName'] = 'InfoWindow'; // register infoWindow ids to NguiMap, so that it can be opened by id\n\n        if (this.elementRef.nativeElement.id) {\n          this.nguiMapComponent.infoWindows[this.elementRef.nativeElement.id] = this;\n        } else {\n          console.error('An InfoWindow must have an id. e.g. id=\"detail\"');\n        } // set google events listeners and emits to this outputs listeners\n\n\n        this.nguiMap.setObjectEvents(OUTPUTS$2, this, 'infoWindow'); // update object when input changes\n\n        this.inputChanges$.pipe(debounceTime(1000), tap(function (changes) {\n          return _this17.nguiMap.updateGoogleObject(_this17.infoWindow, changes);\n        })).subscribe();\n        this.nguiMapComponent.addToMapObjectGroup('InfoWindow', this.infoWindow);\n        this.initialized$.emit(this.infoWindow);\n      }\n      /**\n       * @param {?} anchor\n       * @return {?}\n       */\n\n    }, {\n      key: \"open\",\n      value: function open(anchor) {\n        // set content and open it\n        this.infoWindow.setContent(this.template.element.nativeElement);\n        this.infoWindow.open(this.nguiMapComponent.map, anchor);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        // check if infoWindow exists, and closes it\n        if (this.infoWindow) this.infoWindow.close();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.inputChanges$.complete();\n\n        if (this.infoWindow) {\n          this.nguiMap.clearObjectEvents(OUTPUTS$2, this, 'infoWindow');\n          delete this.infoWindow;\n        }\n      }\n    }]);\n\n    return InfoWindow;\n  }();\n\n  InfoWindow.ɵfac = function InfoWindow_Factory(t) {\n    return new (t || InfoWindow)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NguiMap), ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  InfoWindow.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: InfoWindow,\n    selectors: [[\"info-window\"]],\n    viewQuery: function InfoWindow_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c1, 5, ViewContainerRef);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);\n      }\n    },\n    inputs: {\n      content: \"content\",\n      disableAutoPan: \"disableAutoPan\",\n      maxWidth: \"maxWidth\",\n      pixelOffset: \"pixelOffset\",\n      position: \"position\",\n      zIndex: \"zIndex\",\n      options: \"options\"\n    },\n    outputs: {\n      closeclick: \"closeclick\",\n      content_changed: \"content_changed\",\n      domready: \"domready\",\n      position_changed: \"position_changed\",\n      zindex_changed: \"zindex_changed\",\n      initialized$: \"initialized$\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 0,\n    consts: [[\"template\", \"\"]],\n    template: function InfoWindow_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", null, 0);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return InfoWindow;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$3 = ['position']; // to avoid DOM event conflicts map_*\n\nvar OUTPUTS$3 = ['animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged', 'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick', 'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged', 'map_click', 'map_mouseover', 'map_mouseout', 'map_mouseup', 'map_mousedown', 'map_drag', 'map_dragend'];\n/**\n * Wrapper to a create extend OverlayView at runtime, only after google maps is loaded.\n * Otherwise throws a google is unknown error.\n * @param {?} htmlEl\n * @param {?} position\n * @return {?}\n */\n\nfunction getCustomMarkerOverlayView(htmlEl, position) {\n  var CustomMarkerOverlayView = /*#__PURE__*/function (_google$maps$OverlayV) {\n    _inherits(CustomMarkerOverlayView, _google$maps$OverlayV);\n\n    var _super4 = _createSuper(CustomMarkerOverlayView);\n\n    /**\n     * @param {?} htmlEl\n     * @param {?} position\n     */\n    function CustomMarkerOverlayView(htmlEl, position) {\n      var _this18;\n\n      _classCallCheck(this, CustomMarkerOverlayView);\n\n      _this18 = _super4.call(this);\n      _this18.visible = true;\n\n      _this18.setPosition = function (position) {\n        _this18.htmlEl.style.visibility = 'hidden';\n\n        if (position.constructor.name === 'Array') {\n          _this18.position = new google.maps.LatLng(position[0], position[1]);\n        } else if (typeof position === 'string') {\n          var\n          /** @type {?} */\n          geocoder = new google.maps.Geocoder();\n          geocoder.geocode({\n            address: position\n          }, function (results, status) {\n            if (status === google.maps.GeocoderStatus.OK) {\n              _this18.setPosition(results[0].geometry.location);\n            } else {}\n          });\n        } else if (position && typeof position.lng === 'function') {\n          _this18.position = position;\n        }\n\n        if (_this18.getProjection() && typeof _this18.position.lng === 'function') {\n          var\n          /** @type {?} */\n          positionOnMap = function positionOnMap() {\n            var\n            /** @type {?} */\n            projection = _this18.getProjection();\n\n            if (!projection) {\n              return;\n            }\n\n            var\n            /** @type {?} */\n            posPixel = projection.fromLatLngToDivPixel(_this18.position);\n            var\n            /** @type {?} */\n            x = Math.round(posPixel.x - _this18.htmlEl.offsetWidth / 2);\n            var\n            /** @type {?} */\n            y = Math.round(posPixel.y - _this18.htmlEl.offsetHeight / 2);\n            _this18.htmlEl.style.left = x + 'px';\n            _this18.htmlEl.style.top = y + 'px';\n            _this18.htmlEl.style.visibility = 'visible';\n          };\n\n          if (_this18.htmlEl.offsetWidth && _this18.htmlEl.offsetHeight) {\n            positionOnMap();\n          } else {\n            setTimeout(function () {\n              return positionOnMap();\n            });\n          }\n        }\n      };\n\n      _this18.htmlEl = htmlEl;\n      _this18.position = position;\n      return _this18;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(CustomMarkerOverlayView, [{\n      key: \"onAdd\",\n      value: function onAdd() {\n        this.getPanes().overlayMouseTarget.appendChild(this.htmlEl); // required for correct display inside google maps container\n\n        this.htmlEl.style.position = 'absolute';\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"draw\",\n      value: function draw() {\n        this.setPosition(this.position);\n        this.setZIndex(this.zIndex);\n        this.setVisible(this.visible);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"onRemove\",\n      value: function onRemove() {//\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"getPosition\",\n      value: function getPosition() {\n        return this.position;\n      }\n      /**\n       * @param {?} zIndex\n       * @return {?}\n       */\n\n    }, {\n      key: \"setZIndex\",\n      value: function setZIndex(zIndex) {\n        zIndex && (this.zIndex = zIndex);\n        /* jshint ignore:line */\n\n        this.htmlEl.style.zIndex = this.zIndex;\n      }\n      /**\n       * @param {?} visible\n       * @return {?}\n       */\n\n    }, {\n      key: \"setVisible\",\n      value: function setVisible(visible) {\n        this.htmlEl.style.display = visible ? 'inline-block' : 'none';\n        this.visible = visible;\n      }\n    }]);\n\n    return CustomMarkerOverlayView;\n  }(google.maps.OverlayView);\n\n  return new CustomMarkerOverlayView(htmlEl, position);\n}\n\nvar CustomMarker = /*#__PURE__*/(function () {\n  var CustomMarker = /*#__PURE__*/function () {\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} elementRef\n     * @param {?} nguiMap\n     */\n    function CustomMarker(nguiMapComponent, elementRef, nguiMap) {\n      var _this19 = this;\n\n      _classCallCheck(this, CustomMarker);\n\n      this.nguiMapComponent = nguiMapComponent;\n      this.elementRef = elementRef;\n      this.nguiMap = nguiMap;\n      this.initialized$ = new EventEmitter();\n      this.inputChanges$ = new Subject();\n      this.elementRef.nativeElement.style.display = 'none';\n      OUTPUTS$3.forEach(function (output) {\n        return _this19[output] = new EventEmitter();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(CustomMarker, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this20 = this;\n\n        if (this.nguiMapComponent.mapIdledOnce) {\n          // map is ready already\n          this.initialize();\n        } else {\n          this.nguiMapComponent.mapReady$.subscribe(function (map) {\n            return _this20.initialize();\n          });\n        }\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        this.inputChanges$.next(changes);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.inputChanges$.complete();\n        this.nguiMapComponent.removeFromMapObjectGroup('CustomMarker', this.mapObject);\n\n        if (this.mapObject) {\n          this.nguiMap.clearObjectEvents(OUTPUTS$3, this, 'mapObject');\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"initialize\",\n      value: function initialize() {\n        var _this21 = this;\n\n        this.el = this.elementRef.nativeElement;\n        this.mapObject = getCustomMarkerOverlayView(this.el, this['position']);\n        this.mapObject.setMap(this.nguiMapComponent.map); // set google events listeners and emits to this outputs listeners\n\n        this.nguiMap.setObjectEvents(OUTPUTS$3, this, 'mapObject'); // update object when input changes\n\n        this.inputChanges$.pipe(debounceTime(1000), tap(function (changes) {\n          return _this21.nguiMap.updateGoogleObject(_this21.mapObject, changes);\n        })).subscribe();\n        this.nguiMapComponent.addToMapObjectGroup('CustomMarker', this.mapObject);\n        this.initialized$.emit(this.mapObject);\n      }\n    }]);\n\n    return CustomMarker;\n  }();\n\n  CustomMarker.ɵfac = function CustomMarker_Factory(t) {\n    return new (t || CustomMarker)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NguiMap));\n  };\n\n  CustomMarker.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: CustomMarker,\n    selectors: [[\"custom-marker\"]],\n    inputs: {\n      position: \"position\"\n    },\n    outputs: {\n      animationChanged: \"animationChanged\",\n      click: \"click\",\n      clickableChanged: \"clickableChanged\",\n      cursorChanged: \"cursorChanged\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      draggableChanged: \"draggableChanged\",\n      dragstart: \"dragstart\",\n      flatChanged: \"flatChanged\",\n      iconChanged: \"iconChanged\",\n      mousedown: \"mousedown\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      positionChanged: \"positionChanged\",\n      rightclick: \"rightclick\",\n      shapeChanged: \"shapeChanged\",\n      titleChanged: \"titleChanged\",\n      visibleChanged: \"visibleChanged\",\n      zindexChanged: \"zindexChanged\",\n      map_click: \"map_click\",\n      map_mouseover: \"map_mouseover\",\n      map_mouseout: \"map_mouseout\",\n      map_mouseup: \"map_mouseup\",\n      map_mousedown: \"map_mousedown\",\n      map_drag: \"map_drag\",\n      map_dragend: \"map_dragend\",\n      initialized$: \"initialized$\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function CustomMarker_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return CustomMarker;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$4 = ['center', 'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'map', 'radius', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options', 'geoFallbackCenter'];\nvar OUTPUTS$4 = ['centerChanged', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'radiusChanged', 'rightclick'];\nvar Circle = /*#__PURE__*/(function () {\n  var Circle = /*#__PURE__*/function (_BaseMapDirective2) {\n    _inherits(Circle, _BaseMapDirective2);\n\n    var _super5 = _createSuper(Circle);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function Circle(nguiMapComp) {\n      var _this22;\n\n      _classCallCheck(this, Circle);\n\n      _this22 = _super5.call(this, nguiMapComp, 'Circle', INPUTS$4, OUTPUTS$4);\n      _this22.nguiMapComp = nguiMapComp;\n      _this22.objectOptions =\n      /** @type {?} */\n      {};\n      return _this22;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(Circle, [{\n      key: \"initialize\",\n      value: function initialize() {\n        _get(_getPrototypeOf(Circle.prototype), \"initialize\", this).call(this);\n\n        this.setCenter();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"setCenter\",\n      value: function setCenter() {\n        var _this23 = this;\n\n        if (!this['center']) {\n          this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(function (center) {\n            var\n            /** @type {?} */\n            latLng = new google.maps.LatLng(center.coords.latitude, center.coords.longitude);\n\n            _this23.mapObject.setCenter(latLng);\n          }, function (error) {\n            console.error('ngui-map, error in finding the current position');\n\n            _this23.mapObject.setCenter(_this23.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n          }));\n        } else if (typeof this['center'] === 'string') {\n          this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({\n            address: this['center']\n          }).subscribe(function (results) {\n            _this23.mapObject.setCenter(results[0].geometry.location);\n          }, function (error) {\n            console.error('ngui-map, error in finding location from', _this23['center']);\n\n            _this23.mapObject.setCenter(_this23.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n          }));\n        }\n      }\n    }]);\n\n    return Circle;\n  }(BaseMapDirective);\n\n  Circle.ɵfac = function Circle_Factory(t) {\n    return new (t || Circle)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  Circle.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Circle,\n    selectors: [[\"circle\"], [\"map-circle\"]],\n    inputs: {\n      center: \"center\",\n      clickable: \"clickable\",\n      draggable: \"draggable\",\n      editable: \"editable\",\n      fillColor: \"fillColor\",\n      fillOpacity: \"fillOpacity\",\n      map: \"map\",\n      radius: \"radius\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      strokePosition: \"strokePosition\",\n      strokeWeight: \"strokeWeight\",\n      visible: \"visible\",\n      zIndex: \"zIndex\",\n      options: \"options\",\n      geoFallbackCenter: \"geoFallbackCenter\"\n    },\n    outputs: {\n      centerChanged: \"centerChanged\",\n      click: \"click\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      dragstart: \"dragstart\",\n      mousedown: \"mousedown\",\n      mousemove: \"mousemove\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      radiusChanged: \"radiusChanged\",\n      rightclick: \"rightclick\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return Circle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$5 = ['controlPosition', 'controls', 'drawingMode', 'featureFactory', 'style', 'geoJson', 'geoJsonUrl'];\nvar OUTPUTS$5 = ['addfeature', 'click', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'removefeature', 'removeproperty', 'rightclick', 'setgeometry', 'setproperty'];\nvar DataLayer = /*#__PURE__*/(function () {\n  var DataLayer = /*#__PURE__*/function (_BaseMapDirective3) {\n    _inherits(DataLayer, _BaseMapDirective3);\n\n    var _super6 = _createSuper(DataLayer);\n\n    /**\n     * @param {?} nguiMapComponent\n     */\n    function DataLayer(nguiMapComponent) {\n      _classCallCheck(this, DataLayer);\n\n      return _super6.call(this, nguiMapComponent, 'Data', INPUTS$5, OUTPUTS$5);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(DataLayer, [{\n      key: \"initialize\",\n      value: function initialize() {\n        if (this['geoJson']) {\n          // addGeoJson from an object\n          this.nguiMapComponent.map.data.addGeoJson(this['geoJson']);\n        } else if (this['geoJsonUrl']) {\n          // loadGeoJson from a URL\n          this.nguiMapComponent.map.data.loadGeoJson(this['geoJsonUrl']);\n        } else {\n          this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n          this.nguiMapComponent.map.data.add(this.objectOptions);\n        } // unlike others, data belongs to map. e.g., map.data.loadGeoJson(), map.data.add()\n\n\n        this.mapObject = this.nguiMapComponent.map.data; // set google events listeners and emits to this outputs listeners\n\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n      }\n    }]);\n\n    return DataLayer;\n  }(BaseMapDirective);\n\n  DataLayer.ɵfac = function DataLayer_Factory(t) {\n    return new (t || DataLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  DataLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DataLayer,\n    selectors: [[\"data-layer\"]],\n    inputs: {\n      controlPosition: \"controlPosition\",\n      controls: \"controls\",\n      drawingMode: \"drawingMode\",\n      featureFactory: \"featureFactory\",\n      style: \"style\",\n      geoJson: \"geoJson\",\n      geoJsonUrl: \"geoJsonUrl\"\n    },\n    outputs: {\n      addfeature: \"addfeature\",\n      click: \"click\",\n      dblclick: \"dblclick\",\n      mousedown: \"mousedown\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      removefeature: \"removefeature\",\n      removeproperty: \"removeproperty\",\n      rightclick: \"rightclick\",\n      setgeometry: \"setgeometry\",\n      setproperty: \"setproperty\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return DataLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$6 = ['directions', 'draggable', 'hideRouteList', 'infoWindow', 'panel', 'markerOptions', 'polylineOptions', 'preserveViewport', 'routeIndex', 'suppressBicyclingLayer', 'suppressInfoWindows', 'suppressMarkers', 'suppressPolylines'];\nvar OUTPUTS$6 = ['directions_changed'];\nvar DirectionsRenderer = /*#__PURE__*/(function () {\n  var DirectionsRenderer = /*#__PURE__*/function (_BaseMapDirective4) {\n    _inherits(DirectionsRenderer, _BaseMapDirective4);\n\n    var _super7 = _createSuper(DirectionsRenderer);\n\n    /**\n     * @param {?} nguiMapComponent\n     * @param {?} geolocation\n     */\n    function DirectionsRenderer(nguiMapComponent, geolocation) {\n      var _this24;\n\n      _classCallCheck(this, DirectionsRenderer);\n\n      _this24 = _super7.call(this, nguiMapComponent, 'DirectionsRenderer', INPUTS$6, OUTPUTS$6);\n      _this24.geolocation = geolocation;\n      return _this24;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(DirectionsRenderer, [{\n      key: \"initialize\",\n      value: function initialize() {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n\n        if (typeof this.objectOptions['panel'] === 'string') {\n          // find a Node for panel\n          this.objectOptions['panel'] = document.querySelector(this.objectOptions['panel']);\n        }\n\n        this.directionsService = new google.maps.DirectionsService();\n        this.directionsRenderer = new google.maps.DirectionsRenderer(this.objectOptions);\n        this.directionsRenderer.setMap(this.nguiMapComponent.map); // set google events listeners and emidirectionsRenderer to this outputs listeners\n\n        this.showDirections(this.directionsRequest);\n        this.nguiMap.setObjectEvents(this.outputs, this, 'directionsRenderer');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.directionsRenderer);\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var\n        /** @type {?} */\n        newOptions = {};\n\n        for (var\n        /** @type {?} */\n        key in changes) {\n          if (this.inputs.indexOf(key) !== -1) {\n            newOptions[key] = this.optionBuilder.googlize(changes[key].currentValue);\n          }\n        }\n\n        if (changes['directionsRequest'] && this.directionsRenderer) {\n          this.directionsService && this.showDirections(this.directionsRequest);\n        }\n      }\n      /**\n       * @param {?} directionsRequest\n       * @return {?}\n       */\n\n    }, {\n      key: \"showDirections\",\n      value: function showDirections(directionsRequest) {\n        var _this25 = this;\n\n        this.directionsService.route(directionsRequest, function (response, status) {\n          // in some-case the callback is called during destroy component,\n          // we should make sure directionsRenderer is still defined (cancelling `route` callback is not possible).\n          if (!_this25.directionsRenderer) {\n            return;\n          }\n\n          if (status === google.maps.DirectionsStatus.OK) {\n            _this25.directionsRenderer.setDirections(response);\n          } else {\n            console.error('Directions request failed due to ' + status);\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        _get(_getPrototypeOf(DirectionsRenderer.prototype), \"ngOnDestroy\", this).call(this);\n\n        this.nguiMap.clearObjectEvents(this.outputs, this, 'directionsRenderer');\n      }\n    }]);\n\n    return DirectionsRenderer;\n  }(BaseMapDirective);\n\n  DirectionsRenderer.ɵfac = function DirectionsRenderer_Factory(t) {\n    return new (t || DirectionsRenderer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent), ɵngcc0.ɵɵdirectiveInject(NavigatorGeolocation));\n  };\n\n  DirectionsRenderer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DirectionsRenderer,\n    selectors: [[\"directions-renderer\"]],\n    inputs: {\n      directions: \"directions\",\n      draggable: \"draggable\",\n      hideRouteList: \"hideRouteList\",\n      infoWindow: \"infoWindow\",\n      panel: \"panel\",\n      markerOptions: \"markerOptions\",\n      polylineOptions: \"polylineOptions\",\n      preserveViewport: \"preserveViewport\",\n      routeIndex: \"routeIndex\",\n      suppressBicyclingLayer: \"suppressBicyclingLayer\",\n      suppressInfoWindows: \"suppressInfoWindows\",\n      suppressMarkers: \"suppressMarkers\",\n      suppressPolylines: \"suppressPolylines\",\n      directionsRequest: [\"directions-request\", \"directionsRequest\"]\n    },\n    outputs: {\n      directions_changed: \"directions_changed\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return DirectionsRenderer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$7 = ['options', 'circleOptions', 'drawingControl', 'drawingControlOptions', 'drawingMode', 'map', 'markerOptions', 'polygonOptions', 'polylineOptions', 'rectangleOptions'];\nvar OUTPUTS$7 = ['circlecomplete', 'markercomplete', 'overlaycomplete', 'polygoncomplete', 'polylinecomplete', 'rectanglecomplete'];\nvar DrawingManager = /*#__PURE__*/(function () {\n  var DrawingManager = /*#__PURE__*/function (_BaseMapDirective5) {\n    _inherits(DrawingManager, _BaseMapDirective5);\n\n    var _super8 = _createSuper(DrawingManager);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function DrawingManager(nguiMapComp) {\n      var _this26;\n\n      _classCallCheck(this, DrawingManager);\n\n      _this26 = _super8.call(this, nguiMapComp, 'DrawingManager', INPUTS$7, OUTPUTS$7);\n      _this26.libraryName = 'drawing';\n      return _this26;\n    }\n\n    return _createClass(DrawingManager);\n  }(BaseMapDirective);\n\n  DrawingManager.ɵfac = function DrawingManager_Factory(t) {\n    return new (t || DrawingManager)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  DrawingManager.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DrawingManager,\n    selectors: [[\"drawing-manager\"]],\n    inputs: {\n      options: \"options\",\n      circleOptions: \"circleOptions\",\n      drawingControl: \"drawingControl\",\n      drawingControlOptions: \"drawingControlOptions\",\n      drawingMode: \"drawingMode\",\n      map: \"map\",\n      markerOptions: \"markerOptions\",\n      polygonOptions: \"polygonOptions\",\n      polylineOptions: \"polylineOptions\",\n      rectangleOptions: \"rectangleOptions\"\n    },\n    outputs: {\n      circlecomplete: \"circlecomplete\",\n      markercomplete: \"markercomplete\",\n      overlaycomplete: \"overlaycomplete\",\n      polygoncomplete: \"polygoncomplete\",\n      polylinecomplete: \"polylinecomplete\",\n      rectanglecomplete: \"rectanglecomplete\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return DrawingManager;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$8 = ['url', 'bounds', 'clickable', 'opacity'];\nvar OUTPUTS$8 = ['click', 'dblclick'];\nvar GroundOverlay = /*#__PURE__*/(function () {\n  var GroundOverlay = /*#__PURE__*/function (_BaseMapDirective6) {\n    _inherits(GroundOverlay, _BaseMapDirective6);\n\n    var _super9 = _createSuper(GroundOverlay);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function GroundOverlay(nguiMapComp) {\n      var _this27;\n\n      _classCallCheck(this, GroundOverlay);\n\n      _this27 = _super9.call(this, nguiMapComp, 'GroundOverlay', INPUTS$8, OUTPUTS$8);\n      _this27.objectOptions =\n      /** @type {?} */\n      {};\n      return _this27;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(GroundOverlay, [{\n      key: \"initialize\",\n      value: function initialize() {\n        // url, bounds are not the options of GroundOverlay\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(['clickable', 'opacity'], this); // noinspection TypeScriptUnresolvedFunction\n\n        this.mapObject = new google.maps.GroundOverlay(this['url'], this['bounds'], this.objectOptions);\n        this.mapObject.setMap(this.nguiMapComponent.map);\n        this.mapObject['mapObjectName'] = this.mapObjectName; // set google events listeners and emits to this outputs listeners\n\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n      }\n    }]);\n\n    return GroundOverlay;\n  }(BaseMapDirective);\n\n  GroundOverlay.ɵfac = function GroundOverlay_Factory(t) {\n    return new (t || GroundOverlay)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  GroundOverlay.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: GroundOverlay,\n    selectors: [[\"ground-overlay\"]],\n    inputs: {\n      url: \"url\",\n      bounds: \"bounds\",\n      clickable: \"clickable\",\n      opacity: \"opacity\"\n    },\n    outputs: {\n      click: \"click\",\n      dblclick: \"dblclick\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return GroundOverlay;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$9 = ['data', 'dissipating', 'gradient', 'maxIntensity', 'opacity', 'radius', 'options'];\nvar OUTPUTS$9 = [];\nvar HeatmapLayer = /*#__PURE__*/(function () {\n  var HeatmapLayer = /*#__PURE__*/function (_BaseMapDirective7) {\n    _inherits(HeatmapLayer, _BaseMapDirective7);\n\n    var _super10 = _createSuper(HeatmapLayer);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function HeatmapLayer(nguiMapComp) {\n      var _this28;\n\n      _classCallCheck(this, HeatmapLayer);\n\n      _this28 = _super10.call(this, nguiMapComp, 'HeatmapLayer', INPUTS$9, OUTPUTS$9);\n      _this28.libraryName = 'visualization';\n      return _this28;\n    }\n\n    return _createClass(HeatmapLayer);\n  }(BaseMapDirective);\n\n  HeatmapLayer.ɵfac = function HeatmapLayer_Factory(t) {\n    return new (t || HeatmapLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  HeatmapLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: HeatmapLayer,\n    selectors: [[\"heatmap-layer\"]],\n    inputs: {\n      data: \"data\",\n      dissipating: \"dissipating\",\n      gradient: \"gradient\",\n      maxIntensity: \"maxIntensity\",\n      opacity: \"opacity\",\n      radius: \"radius\",\n      options: \"options\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return HeatmapLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$10 = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex', 'options'];\nvar OUTPUTS$10 = ['click', 'defaultviewport_changed', 'status_changed'];\nvar KmlLayer = /*#__PURE__*/(function () {\n  var KmlLayer = /*#__PURE__*/function (_BaseMapDirective8) {\n    _inherits(KmlLayer, _BaseMapDirective8);\n\n    var _super11 = _createSuper(KmlLayer);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function KmlLayer(nguiMapComp) {\n      _classCallCheck(this, KmlLayer);\n\n      return _super11.call(this, nguiMapComp, 'KmlLayer', INPUTS$10, OUTPUTS$10);\n    }\n\n    return _createClass(KmlLayer);\n  }(BaseMapDirective);\n\n  KmlLayer.ɵfac = function KmlLayer_Factory(t) {\n    return new (t || KmlLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  KmlLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: KmlLayer,\n    selectors: [[\"kml-layer\"]],\n    inputs: {\n      clickable: \"clickable\",\n      preserveViewport: \"preserveViewport\",\n      screenOverlays: \"screenOverlays\",\n      suppressInfoWindows: \"suppressInfoWindows\",\n      url: \"url\",\n      zIndex: \"zIndex\",\n      options: \"options\"\n    },\n    outputs: {\n      click: \"click\",\n      defaultviewport_changed: \"defaultviewport_changed\",\n      status_changed: \"status_changed\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return KmlLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$11 = ['anchorPoint', 'animation', 'clickable', 'cursor', 'draggable', 'icon', 'label', 'opacity', 'optimized', 'place', 'position', 'shape', 'title', 'visible', 'zIndex', 'options', 'geoFallbackPosition'];\nvar OUTPUTS$11 = ['animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged', 'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick', 'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged'];\nvar Marker = /*#__PURE__*/(function () {\n  var Marker = /*#__PURE__*/function (_BaseMapDirective9) {\n    _inherits(Marker, _BaseMapDirective9);\n\n    var _super12 = _createSuper(Marker);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function Marker(nguiMapComp) {\n      var _this29;\n\n      _classCallCheck(this, Marker);\n\n      _this29 = _super12.call(this, nguiMapComp, 'Marker', INPUTS$11, OUTPUTS$11);\n      _this29.nguiMapComp = nguiMapComp;\n      _this29.objectOptions =\n      /** @type {?} */\n      {};\n      return _this29;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(Marker, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this30 = this;\n\n        if (this.nguiMapComponent.mapIdledOnce) {\n          // map is ready already\n          this.initialize();\n        } else {\n          this.nguiMapComponent.mapReady$.subscribe(function (map) {\n            return _this30.initialize();\n          });\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"initialize\",\n      value: function initialize() {\n        _get(_getPrototypeOf(Marker.prototype), \"initialize\", this).call(this);\n\n        this.setPosition();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"setPosition\",\n      value: function setPosition() {\n        var _this31 = this;\n\n        if (!this['position']) {\n          this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(function (position) {\n            var\n            /** @type {?} */\n            latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n\n            _this31.mapObject.setPosition(latLng);\n          }, function (error) {\n            console.error('ngui-map, error finding the current location');\n\n            _this31.mapObject.setPosition(_this31.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n          }));\n        } else if (typeof this['position'] === 'string') {\n          this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({\n            address: this['position']\n          }).subscribe(function (results) {\n            _this31.mapObject.setPosition(results[0].geometry.location);\n          }, function (error) {\n            console.error('ngui-map, error finding the location from', _this31['position']);\n\n            _this31.mapObject.setPosition(_this31.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n          }));\n        }\n      }\n    }]);\n\n    return Marker;\n  }(BaseMapDirective);\n\n  Marker.ɵfac = function Marker_Factory(t) {\n    return new (t || Marker)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  Marker.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Marker,\n    selectors: [[\"marker\"]],\n    inputs: {\n      anchorPoint: \"anchorPoint\",\n      animation: \"animation\",\n      clickable: \"clickable\",\n      cursor: \"cursor\",\n      draggable: \"draggable\",\n      icon: \"icon\",\n      label: \"label\",\n      opacity: \"opacity\",\n      optimized: \"optimized\",\n      place: \"place\",\n      position: \"position\",\n      shape: \"shape\",\n      title: \"title\",\n      visible: \"visible\",\n      zIndex: \"zIndex\",\n      options: \"options\",\n      geoFallbackPosition: \"geoFallbackPosition\"\n    },\n    outputs: {\n      animationChanged: \"animationChanged\",\n      click: \"click\",\n      clickableChanged: \"clickableChanged\",\n      cursorChanged: \"cursorChanged\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      draggableChanged: \"draggableChanged\",\n      dragstart: \"dragstart\",\n      flatChanged: \"flatChanged\",\n      iconChanged: \"iconChanged\",\n      mousedown: \"mousedown\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      positionChanged: \"positionChanged\",\n      rightclick: \"rightclick\",\n      shapeChanged: \"shapeChanged\",\n      titleChanged: \"titleChanged\",\n      visibleChanged: \"visibleChanged\",\n      zindexChanged: \"zindexChanged\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return Marker;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar PlacesAutoComplete = /*#__PURE__*/(function () {\n  var PlacesAutoComplete = /*#__PURE__*/_createClass(\n  /**\n   * @param {?} optionBuilder\n   * @param {?} elementRef\n   * @param {?} apiLoader\n   */\n  function PlacesAutoComplete(optionBuilder, elementRef, apiLoader) {\n    var _this32 = this;\n\n    _classCallCheck(this, PlacesAutoComplete);\n\n    this.optionBuilder = optionBuilder;\n    this.elementRef = elementRef;\n    this.apiLoader = apiLoader;\n    this.place_changed = new EventEmitter();\n    this.initialized$ = new EventEmitter(); // only called when map is ready\n\n    this.initialize = function () {\n      _this32.objectOptions = _this32.optionBuilder.googlizeAllInputs(['bounds', 'componentRestrictions', 'types'], _this32);\n\n      if (!google.maps.places) {\n        throw missingLibraryError('PlacesAutoComplete', 'places');\n      }\n\n      _this32.autocomplete = new google.maps.places.Autocomplete(_this32.elementRef.nativeElement, _this32.objectOptions);\n\n      _this32.autocomplete.addListener('place_changed', function (place) {\n        _this32.place_changed.emit(_this32.autocomplete.getPlace());\n      });\n\n      _this32.initialized$.emit(_this32.autocomplete);\n    };\n\n    apiLoader.load();\n    apiLoader.api$.pipe(first()).subscribe(function () {\n      return _this32.initialize();\n    });\n  });\n\n  PlacesAutoComplete.ɵfac = function PlacesAutoComplete_Factory(t) {\n    return new (t || PlacesAutoComplete)(ɵngcc0.ɵɵdirectiveInject(OptionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgMapApiLoader));\n  };\n\n  PlacesAutoComplete.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: PlacesAutoComplete,\n    selectors: [[\"\", \"places-auto-complete\", \"\"]],\n    inputs: {\n      bounds: \"bounds\",\n      componentRestrictions: \"componentRestrictions\",\n      types: \"types\"\n    },\n    outputs: {\n      place_changed: \"place_changed\",\n      initialized$: \"initialized$\"\n    }\n  });\n  /** @nocollapse */\n\n  return PlacesAutoComplete;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$12 = ['clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'paths', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options'];\nvar OUTPUTS$12 = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];\nvar Polygon = /*#__PURE__*/(function () {\n  var Polygon = /*#__PURE__*/function (_BaseMapDirective10) {\n    _inherits(Polygon, _BaseMapDirective10);\n\n    var _super13 = _createSuper(Polygon);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function Polygon(nguiMapComp) {\n      _classCallCheck(this, Polygon);\n\n      return _super13.call(this, nguiMapComp, 'Polygon', INPUTS$12, OUTPUTS$12);\n    }\n\n    return _createClass(Polygon);\n  }(BaseMapDirective);\n\n  Polygon.ɵfac = function Polygon_Factory(t) {\n    return new (t || Polygon)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  Polygon.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Polygon,\n    selectors: [[\"polygon\"], [\"map-polygon\"]],\n    inputs: {\n      clickable: \"clickable\",\n      draggable: \"draggable\",\n      editable: \"editable\",\n      fillColor: \"fillColor\",\n      fillOpacity: \"fillOpacity\",\n      geodesic: \"geodesic\",\n      paths: \"paths\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      strokePosition: \"strokePosition\",\n      strokeWeight: \"strokeWeight\",\n      visible: \"visible\",\n      zIndex: \"zIndex\",\n      options: \"options\"\n    },\n    outputs: {\n      click: \"click\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      dragstart: \"dragstart\",\n      mousedown: \"mousedown\",\n      mousemove: \"mousemove\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      rightclick: \"rightclick\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return Polygon;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$13 = ['clickable', 'draggable', 'editable', 'geodesic', 'icons', 'path', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'options'];\nvar OUTPUTS$13 = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];\nvar Polyline = /*#__PURE__*/(function () {\n  var Polyline = /*#__PURE__*/function (_BaseMapDirective11) {\n    _inherits(Polyline, _BaseMapDirective11);\n\n    var _super14 = _createSuper(Polyline);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function Polyline(nguiMapComp) {\n      _classCallCheck(this, Polyline);\n\n      return _super14.call(this, nguiMapComp, 'Polyline', INPUTS$13, OUTPUTS$13);\n    }\n\n    return _createClass(Polyline);\n  }(BaseMapDirective);\n\n  Polyline.ɵfac = function Polyline_Factory(t) {\n    return new (t || Polyline)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  Polyline.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Polyline,\n    selectors: [[\"polyline\"]],\n    inputs: {\n      clickable: \"clickable\",\n      draggable: \"draggable\",\n      editable: \"editable\",\n      geodesic: \"geodesic\",\n      icons: \"icons\",\n      path: \"path\",\n      strokeColor: \"strokeColor\",\n      strokeOpacity: \"strokeOpacity\",\n      strokeWeight: \"strokeWeight\",\n      visible: \"visible\",\n      zIndex: \"zIndex\",\n      options: \"options\"\n    },\n    outputs: {\n      click: \"click\",\n      dblclick: \"dblclick\",\n      drag: \"drag\",\n      dragend: \"dragend\",\n      dragstart: \"dragstart\",\n      mousedown: \"mousedown\",\n      mousemove: \"mousemove\",\n      mouseout: \"mouseout\",\n      mouseover: \"mouseover\",\n      mouseup: \"mouseup\",\n      rightclick: \"rightclick\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return Polyline;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$14 = ['selector', 'options', 'addressControl', 'addressControlOptions', 'clickToGo', 'disableDefaultUI', 'disableDoubleClickZoom', 'enableCloseButton', 'fullscreenControl', 'fullscreenControlOptions', 'imageDateControl', 'linksControl', 'motionTracking', 'motionTrackingControl', 'panControl', 'panControlOptions', 'pano', 'position', 'pov', 'scrollwheel', 'showRoadLabels', 'visible', 'zoomControl', 'zoomControlOptions'];\nvar OUTPUTS$14 = ['closeclick', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'status_changed', 'visible_changed', 'zoom_changed'];\nvar StreetViewPanorama = /*#__PURE__*/(function () {\n  var StreetViewPanorama = /*#__PURE__*/function (_BaseMapDirective12) {\n    _inherits(StreetViewPanorama, _BaseMapDirective12);\n\n    var _super15 = _createSuper(StreetViewPanorama);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function StreetViewPanorama(nguiMapComp) {\n      _classCallCheck(this, StreetViewPanorama);\n\n      return _super15.call(this, nguiMapComp, 'StreetViewPanorama', INPUTS$14, OUTPUTS$14);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(StreetViewPanorama, [{\n      key: \"initialize\",\n      value: function initialize() {\n        this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n        var\n        /** @type {?} */\n        element;\n\n        if (this.objectOptions.selector) {\n          // noinspection TypeScriptValidateTypes\n          element = document.querySelector(this['selector']);\n          delete this.objectOptions.selector;\n        } else {\n          element = this.nguiMapComponent.el;\n        } // will be set after geocoded\n\n\n        typeof this.objectOptions.position === 'string' && delete this.objectOptions.position;\n        this.mapObject = new google.maps[this.mapObjectName](element, this.objectOptions);\n        this.mapObject['mapObjectName'] = this.mapObjectName;\n        this.mapObject['nguiMapComponent'] = this.nguiMapComponent; // set google events listeners and emits to this outputs listeners\n\n        this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n        this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n        this.initialized$.emit(this.mapObject);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.nguiMapComponent.el) {\n          this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n        }\n      }\n    }]);\n\n    return StreetViewPanorama;\n  }(BaseMapDirective);\n\n  StreetViewPanorama.ɵfac = function StreetViewPanorama_Factory(t) {\n    return new (t || StreetViewPanorama)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  StreetViewPanorama.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: StreetViewPanorama,\n    selectors: [[\"street-view-panorama\"]],\n    inputs: {\n      selector: \"selector\",\n      options: \"options\",\n      addressControl: \"addressControl\",\n      addressControlOptions: \"addressControlOptions\",\n      clickToGo: \"clickToGo\",\n      disableDefaultUI: \"disableDefaultUI\",\n      disableDoubleClickZoom: \"disableDoubleClickZoom\",\n      enableCloseButton: \"enableCloseButton\",\n      fullscreenControl: \"fullscreenControl\",\n      fullscreenControlOptions: \"fullscreenControlOptions\",\n      imageDateControl: \"imageDateControl\",\n      linksControl: \"linksControl\",\n      motionTracking: \"motionTracking\",\n      motionTrackingControl: \"motionTrackingControl\",\n      panControl: \"panControl\",\n      panControlOptions: \"panControlOptions\",\n      pano: \"pano\",\n      position: \"position\",\n      pov: \"pov\",\n      scrollwheel: \"scrollwheel\",\n      showRoadLabels: \"showRoadLabels\",\n      visible: \"visible\",\n      zoomControl: \"zoomControl\",\n      zoomControlOptions: \"zoomControlOptions\"\n    },\n    outputs: {\n      closeclick: \"closeclick\",\n      pano_changed: \"pano_changed\",\n      position_changed: \"position_changed\",\n      pov_changed: \"pov_changed\",\n      resize: \"resize\",\n      status_changed: \"status_changed\",\n      visible_changed: \"visible_changed\",\n      zoom_changed: \"zoom_changed\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return StreetViewPanorama;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$15 = ['autoRefresh', 'options'];\nvar OUTPUTS$15 = [];\nvar TrafficLayer = /*#__PURE__*/(function () {\n  var TrafficLayer = /*#__PURE__*/function (_BaseMapDirective13) {\n    _inherits(TrafficLayer, _BaseMapDirective13);\n\n    var _super16 = _createSuper(TrafficLayer);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function TrafficLayer(nguiMapComp) {\n      _classCallCheck(this, TrafficLayer);\n\n      return _super16.call(this, nguiMapComp, 'TrafficLayer', INPUTS$15, OUTPUTS$15);\n    }\n\n    return _createClass(TrafficLayer);\n  }(BaseMapDirective);\n\n  TrafficLayer.ɵfac = function TrafficLayer_Factory(t) {\n    return new (t || TrafficLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  TrafficLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TrafficLayer,\n    selectors: [[\"traffic-layer\"]],\n    inputs: {\n      autoRefresh: \"autoRefresh\",\n      options: \"options\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return TrafficLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar INPUTS$16 = [];\nvar OUTPUTS$16 = [];\nvar TransitLayer = /*#__PURE__*/(function () {\n  var TransitLayer = /*#__PURE__*/function (_BaseMapDirective14) {\n    _inherits(TransitLayer, _BaseMapDirective14);\n\n    var _super17 = _createSuper(TransitLayer);\n\n    /**\n     * @param {?} nguiMapComp\n     */\n    function TransitLayer(nguiMapComp) {\n      _classCallCheck(this, TransitLayer);\n\n      return _super17.call(this, nguiMapComp, 'TransitLayer', INPUTS$16, OUTPUTS$16);\n    }\n\n    return _createClass(TransitLayer);\n  }(BaseMapDirective);\n\n  TransitLayer.ɵfac = function TransitLayer_Factory(t) {\n    return new (t || TransitLayer)(ɵngcc0.ɵɵdirectiveInject(NguiMapComponent));\n  };\n\n  TransitLayer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TransitLayer,\n    selectors: [[\"transit-layer\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  /** @nocollapse */\n\n  return TransitLayer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\nvar COMPONENTS_DIRECTIVES = [NguiMapComponent, InfoWindow, Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay, TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer, StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer, DrawingManager];\nvar NguiMapModule = /*#__PURE__*/(function () {\n  var NguiMapModule = /*#__PURE__*/function () {\n    function NguiMapModule() {\n      _classCallCheck(this, NguiMapModule);\n    }\n\n    _createClass(NguiMapModule, null, [{\n      key: \"forRoot\",\n      value:\n      /**\n       * @param {?=} config\n       * @return {?}\n       */\n      function forRoot() {\n        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: NguiMapModule,\n          providers: [{\n            provide: NG_MAP_CONFIG_TOKEN,\n            useValue: config\n          }]\n        };\n      }\n    }]);\n\n    return NguiMapModule;\n  }();\n\n  NguiMapModule.ɵfac = function NguiMapModule_Factory(t) {\n    return new (t || NguiMapModule)();\n  };\n\n  NguiMapModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NguiMapModule\n  });\n  NguiMapModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [GeoCoder, NavigatorGeolocation, NguiMap, OptionBuilder, {\n      provide: NgMapApiLoader,\n      useClass: NgMapAsyncCallbackApiLoader\n    }],\n    imports: [[CommonModule]]\n  });\n  return NguiMapModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NguiMapModule, {\n    declarations: function declarations() {\n      return [NguiMapComponent, InfoWindow, Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay, TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer, StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer, DrawingManager];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [NguiMapComponent, InfoWindow, Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay, TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer, StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer, DrawingManager];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { BicyclingLayer, NavigatorGeolocation, OptionBuilder, NG_MAP_CONFIG_TOKEN, NgMapApiLoader, NgMapAsyncApiLoader, NgMapAsyncCallbackApiLoader, NguiMapComponent, InfoWindow, CustomMarker, Circle, DataLayer, DirectionsRenderer, DrawingManager, GeoCoder, GroundOverlay, HeatmapLayer, KmlLayer, Marker, NguiMap, PlacesAutoComplete, Polygon, Polyline, StreetViewPanorama, TrafficLayer, TransitLayer, NguiMapModule, BaseMapDirective as ɵa }; //# sourceMappingURL=ngui-map.js.map","map":null,"metadata":{},"sourceType":"module"}